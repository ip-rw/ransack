package walk

import (
	"errors"
	"log"
	"os"
	"path/filepath"
)

// Dirs is a structure for scanning the directory tree.
// Its Next method returns the next Go source directory it finds.
// Although it can be used to scan the tree multiple times, it
// only walks the tree once, caching the data it finds.
type Dirs struct {
	scan   chan string // directories generated by walk.
	paths  []string    // Cache of known paths.
	offset int         // Counter for Next.
}

// Reset puts the scan back at the beginning.
func (d *Dirs) Reset() {
	d.offset = 0
}

// Next returns the next directory in the scan. The boolean
// is false when the scan is done.
func (d *Dirs) Next() (string, bool) {
	if d.offset < len(d.paths) {
		path := d.paths[d.offset]
		d.offset++
		return path, true
	}
	path, ok := <-d.scan
	if !ok {
		return "", false
	}
	d.paths = append(d.paths, path)
	d.offset++
	return path, ok
}

// walk walks the trees in GOROOT and GOPATH.
func Walk(path string, callback func(dir string, info os.FileInfo, err error) error) {
	var dirs Dirs
	//d.bfsWalkRoot(build.Default.GOROOT)
	dirs.paths = make([]string, 0, 1000)
	dirs.scan = make(chan string)

	dirs.bfsWalkRoot(path, callback)
	close(dirs.scan)
}

var SkipDir = errors.New("skip directory")

// bfsWalkRoot walks a single directory hierarchy in breadth-first lexical order.
// Each Go source directory it finds is delivered on d.scan.
func (d *Dirs) bfsWalkRoot(root string, callback func(dir string, info os.FileInfo, err error) error) {
	// this is the queue of directories to examine in this pass.
	this := []string{}
	// next is the queue of directories to examine in the next pass.
	next := []string{root}

	for len(next) > 0 {
		this, next = next, this[0:0]
		for _, dir := range this {
			fd, err := os.Open(dir)
			if err != nil {
				log.Print(err)
				continue
			}
			entries, err := fd.Readdir(0)
			fd.Close()
			if err != nil {
				log.Print(err)
				continue
			}
			for _, entry := range entries {
				name := entry.Name()
				// For plain files, remember if this directory contains any .go
				// source files, but ignore them otherwise.
				err := callback(dir, entry, nil)
				if err != nil {
					if err == SkipDir {
						continue
					} else {
						return
					}
				}
				if !entry.IsDir() {
					continue
				}
				// Entry is a directory.
				// No .git or other dot nonsense please.
				//if strings.HasPrefix(name, ".") {
				//	continue
				//}
				// Remember this (fully qualified) directory for the next pass.
				next = append(next, filepath.Join(dir, name))
				//d.scan <- dir
			}
		}

	}
}
